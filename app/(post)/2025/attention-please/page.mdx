export const metadata = {
  title: 'Attention please',
  description: 'An overview of different attention variants',
  openGraph: {
    title: 'Attention please',
    description: 'An overview of different attention variants',
    images: [{ url: '/og/attention-please' }]
  }
};

<FloatingTOC
  items={[
    { text: "self-attention", href: "#self-attention" },
    { text: "causal self-attention", href: "#causal-self-attention" },
    { text: "multi-head attention", href: "#multi-head-attention" },
    { text: "multi-query attention", href: "#multi-query-attention" },
    { text: "grouped-query attention", href: "#grouped-query-attention" },
    { text: "summary", href: "#summary" },
    { text: "resources", href: "#resources" }
  ]}
/>

It's kind of wild that *attention* is a quantifiable concept. I don't have a way of measuring how I personally pay attention, but I imagine it's very primitive.

If you told me to take out the trash on Monday night because it's really full and pickup day is Tuesday, my brain would probably compile it to something like "trash, Monday night". Just the essential keywords.

But for transformer models, attention is calculable.

> An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.
> - [Attention Is All You Need](https://huggingface.co/papers/1706.03762)

This post tries to very simply and very plainly explain how the original self-attention (and several variants of it, but not all) works while eschewing as much jargon and fancy language as possible.

<Tip text="If you're interested in calculating attention by hand, click 'Show calculations'. This really helped solidify my understanding of how attention works!" />

## self-attention [#self-attention]

Self-attention (scaled dot-product attention) computes how much each word in a sequence should "pay attention" to every other word in that same sequence. It's what makes transformers contextually aware.

You need 3 matrices to compute self-attention. These matrices are created by multiplying <HoverWord 
  word="word embeddings"
  description="Vectors of numbers that represent words in a way that captures meaning and relationships."
/> by 3 <HoverWord
  word="weight matrices"
  description="Learnable parameters optimized during training."
/>
(W<sub>k</sub>, W<sub>q</sub>, W<sub>v</sub>).

- Query (Q) is compared to all the Ks (including itself) to calculate how much attention to pay to each word. Q is the information you're looking for.
- Key (K) is multiplied by Q (<HoverWord
  word="dot product"
  description="A mathematical operation that compares how similar two vectors are. In the context of transformers, it compares how similar two tokens are."
/>) to produce the attention scores for each word. K is the information a word contains.

  The attention scores are *scaled* by dividing by the square root of the vector dimension. For example, if the dimension is 64, divide the attention scores by 8. Scaling prevents the attention scores from becoming too large or too small.

  Apply a <HoverWord
    word="softmax"
    description="A function that exponentiates a value and divides by the sum of all the exponentiated values."
  /> function to the scores to convert them into probabilities that add up to 1. Scaling also smooths out the softmax function by preventing any one value from dominating the rest.

- Value (V) weights each word with an attention score to determine what information every other word offers. V is the information each word contributes.

Try calculating the self-attention score for the word `Fear` by hand in the following sequence to really get a feel for how it works.

<Collapsible trigger="Show calculations">

<Table 
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "[0.2, 0.1, 0.8]", "[0.3, 0.5, 0.2]", "[0.1, 0.7, 0.4]"],
    ["is", "[0.5, 0.2, 0.3]", "[0.1, 0.4, 0.6]", "[0.8, 0.1, 0.2]"],
  ]}
  className="my-8"
/>

1. Multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.

    `[0.2, 0.1, 0.8]*[0.3, 0.5, 0.2]` = `0.2*0.3 + 0.1*0.5 + 0.8*0.2` = `0.31`

    `[0.2, 0.1, 0.8]*[0.1, 0.4, 0.6]` = `0.2*0.1 + 0.1*0.4 + 0.8*0.6` = `0.54`

2. Scale the attention scores by dividing by the square root of 3 (the vector dimension).

    `[0.31/1.732, 0.54/1.732]` = `[0.179, 0.311]`

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    `[e^0.179 / (e^0.179 + e^0.311), e^0.311 / (e^0.179 + e^0.311)]` = `[0.467, 0.532]`

4. Weight V by the attention scores.

    `0.467*[0.1, 0.7, 0.4]` = `[0.0467, 0.3269, 0.1868]`

    `0.532*[0.8, 0.1, 0.2]` = `[0.4256, 0.0532, 0.1064]`

5. Add the weighted values together.

    `[0.0467+0.4256, 0.3269+0.0532, 0.1868+0.1064]` = `[0.4723, 0.3801, 0.2932]`

This is the final self-attention score for `Fear`.
</Collapsible>

## causal self-attention [#causal-self-attention]

Causal self-attention is used in decoder models like [GPT](https://huggingface.co/openai-community/gpt2). These models predict the next word in a sequence, so it is important to mask future words to prevent it from cheating.

In the mask, words that should be blocked are set to -∞, and the softmax of -∞ becomes ~0.

Try calculating the causal self-attention score for the word `is` by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table 
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "[0.2, 0.1, 0.8]", "[0.3, 0.5, 0.2]", "[0.1, 0.7, 0.4]"],
    ["is", "[0.5, 0.2, 0.3]", "[0.1, 0.4, 0.6]", "[0.8, 0.1, 0.2]"],
    ["the", "[0.1, 0.6, 0.3]", "[0.4, 0.2, 0.5]", "[0.2, 0.9, 0.1]"],
  ]}
  className="my-8"
/>

1. Multiply Q<sub>is</sub> by K for every word in the sequence to get the attention score.

    `[0.5, 0.2, 0.3]*[0.3, 0.5, 0.2]` = `0.5*0.3+0.2*0.5+0.3*0.2` = `0.31`

    `[0.5, 0.2, 0.3]*[0.1, 0.4, 0.6]` = `0.5*0.1+0.2*0.4+0.3*0.6` = `0.38`

    `[0.5, 0.2, 0.3]*[0.4, 0.2, 0.5]` = `0.5*0.4+0.2*0.2+0.3*0.5` = `0.41`

    The attention score is `[0.31, 0.38, 0.41]`.

2. Scale the attention scores by dividing by the square root of 3 (the vector dimension).

    `[0.31/1.732, 0.38/1.732, 0.41/1.732]` = `[0.179, 0.219, 0.237]`

3. Set `0.237` to `-inf` to block attention to the future word (`the`).

    `[0.179, 0.3219, -inf]`
    
    The rest of the calculation is the same as self-attention.
</Collapsible>

## multi-head attention [#multi-head-attention]

<div style={{ display: 'flex', justifyContent: 'center', margin: '2rem 0' }}>
  <div style={{ width: '1000px', height: '300px', position: 'relative', borderRadius: 16, left: '50px' }}>
    {/* Blue boxes */}
    <div style={{ width: 91.47, height: 47.58, left: 382, top: 74, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
    <div style={{ width: 91.47, height: 47.58, left: 382, top: 128.09, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
    <div style={{ width: 91.47, height: 47.58, left: 382, top: 182.18, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
    
    {/* Scale + softmax labels */}
    <div style={{ width: 79, height: 14, left: 124, top: 29, position: 'absolute', color: '#64748B', fontSize: 8, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>scale + softmax</div>
    <div style={{ width: 79, height: 14, left: 124, top: 133, position: 'absolute', color: '#64748B', fontSize: 8, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>scale + softmax</div>
    <div style={{ width: 79, height: 14, left: 124, top: 242, position: 'absolute', color: '#64748B', fontSize: 8, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>scale + softmax</div>
    
    {/* Purple Value boxes */}
    <div style={{ width: 91.47, height: 47.58, left: 206, top: 16, position: 'absolute', background: '#EDE9FE', borderRadius: 16, border: '3px #A78BFA solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 224.41, top: 27.89, position: 'absolute', color: '#A78BFA', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Value</div>
    
    {/* Animated dashed lines */}
    <AnimatedDashedLine x1={124.32} y1={47.58} x2={195.97} y2={47.58} />
    <AnimatedDashedLine x1={302.56} y1={48} x2={382} y2={152.39} />
    <AnimatedDashedLine x1={300} y1={152.39} x2={382} y2={152.39} />
    <AnimatedDashedLine x1={300.74} y1={260.56} x2={380} y2={152.39} />
    
    {/* Orange Key boxes */}
    <div style={{ width: 91.47, height: 47.58, left: 23.22, top: 0, position: 'absolute', background: '#FFEDD5', borderRadius: 16, border: '3px #FB923C solid' }} />
    <div style={{ width: 32.85, height: 23.50, left: 52.39, top: 11.89, position: 'absolute', color: '#FB923C', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Key</div>
    
    {/* Green Query boxes */}
    <div style={{ width: 91.47, height: 47.58, left: 0, top: 35.68, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 47.58, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
    
    {/* Bottom row elements */}
    <div style={{ width: 91.47, height: 47.58, left: 206, top: 229.52, position: 'absolute', background: '#EDE9FE', borderRadius: 16, border: '3px #A78BFA solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 224.41, top: 241.42, position: 'absolute', color: '#A78BFA', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Value</div>
    <AnimatedDashedLine x1={124.32} y1={261.10} x2={195.97} y2={261.10} />
    <div style={{ width: 91.47, height: 47.58, left: 23.22, top: 213.52, position: 'absolute', background: '#FFEDD5', borderRadius: 16, border: '3px #FB923C solid' }} />
    <div style={{ width: 91.47, height: 47.58, left: 0, top: 249.20, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 261.10, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
    <div style={{ width: 32.85, height: 23.50, left: 52.39, top: 225.42, position: 'absolute', color: '#FB923C', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Key</div>
    
    {/* Middle row elements */}
    <div style={{ width: 91.47, height: 47.58, left: 206, top: 120.50, position: 'absolute', background: '#EDE9FE', borderRadius: 16, border: '3px #A78BFA solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 224.41, top: 132.39, position: 'absolute', color: '#A78BFA', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Value</div>
    <AnimatedDashedLine x1={124.32} y1={152.07} x2={195.97} y2={152.07} />
    <div style={{ width: 91.47, height: 47.58, left: 23.22, top: 104.50, position: 'absolute', background: '#FFEDD5', borderRadius: 16, border: '3px #FB923C solid' }} />
    <div style={{ width: 91.47, height: 47.58, left: 0, top: 140.18, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 152.07, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
    <div style={{ width: 32.85, height: 23.50, left: 52.39, top: 116.39, position: 'absolute', color: '#FB923C', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Key</div>
  </div>
</div>

Self-attention is a single *head* of attention. Multi-head attention (MHA) adds more heads to learn other things about a sentence from different perspectives.

The calculations are the same as self-attention, but the <HoverWord
  word="embedding size"
  description="The size of the vector used to represent a word. A larger size includes more information, but it also increases the computational cost."
/> is split by the number of heads. Each head independently computes the scaled dot-product attention on their slice of data. At the end, the outputs are combined and multiplied by a weight matrix to blend all the information together.

MHA is still used by models today such as [DeepSeek-R1](https://huggingface.co/deepseek-ai/DeepSeek-R1).

Try calculating the multi-head attention score for the word `Fear` by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table 
  title="Head 1"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "2.0", "2.0", "2.0"],
    ["is", "3.0", "3.0", "3.0"],
  ]}
  className="my-8"
/>

<Table 
  title="Head 2"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "4.0", "1.0", "3.0"],
    ["is", "6.0", "1.5", "4.5"],
  ]}
  className="my-8"
/>

1. For both heads, multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[2.0*2.0, 2.0*3.0]` = `[4.0, 6.0]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0*1.0, 4.0*1.5]` = `[4.0, 6.0]`
      </div>
    </div>

2. Scale the attention scores of each head by dividing by the square root of 2 (the vector dimension).

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`
      </div>
    </div>

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.804]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.804]`
      </div>
    </div>

3. Weight V by the attention scores.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `0.195*2.0`+`0.804*3.0` = `2.802`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `0.195*3.0`+`0.804*4.5` = `4.203`
      </div>
    </div>

4. Concatenate the outputs of each head and multiply by a <HoverWord
  word="transposed"
  description="The transpose of a matrix switches the rows and columns. A m x n matrix becomes a n x m matrix."
/> weight matrix (Wᵀ) to combine the information.

    `[2.802, 4.203]*[1.0, 1.0]ᵀ` = `4.203`

This is the final multi-head attention score for `Fear`.

</Collapsible>

## multi-query attention [#multi-query-attention]

<div style={{ display: 'flex', justifyContent: 'center', margin: '2rem 0' }}>
  <div style={{ width: '1000px', height: '300px', position: 'relative', borderRadius: 16, left: '50px' }}>
    {/* Purple Value box */}
    <div style={{ width: 91.47, height: 47.58, left: 242, top: 69.32, position: 'absolute', background: '#EDE9FE', borderRadius: 16, border: '3px #A78BFA solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 260.41, top: 81.21, position: 'absolute', color: '#A78BFA', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Value</div>
    
    {/* Blue boxes */}
    <div style={{ width: 91.47, height: 47.58, left: 416, top: 46.32, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
    <div style={{ width: 91.47, height: 47.58, left: 416, top: 100.41, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
    <div style={{ width: 91.47, height: 47.58, left: 416, top: 154.50, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
    
    {/* Animated dashed lines */}
    <AnimatedDashedLine x1={111} y1={128.32} x2={210} y2={128.32} />
    <AnimatedDashedLine x1={323} y1={128.32} x2={400} y2={128.32} />
    <AnimatedDashedLine x1={111} y1={23.32} x2={210} y2={128.32} />
    <AnimatedDashedLine x1={111} y1={237.32} x2={210} y2={128.32} />
    
    {/* Orange Key box */}
    <div style={{ width: 91.47, height: 47.58, left: 216, top: 104.64, position: 'absolute', background: '#FFEDD5', borderRadius: 16, border: '3px #FB923C solid' }} />
    <div style={{ width: 32.85, height: 23.50, left: 245.17, top: 116.53, position: 'absolute', color: '#FB923C', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Key</div>
    
    {/* Green Query boxes */}
    <div style={{ width: 91.47, height: 47.58, left: 0, top: 0, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 11.89, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
    <div style={{ width: 91.47, height: 47.58, left: 0, top: 213.52, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 225.42, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
    <div style={{ width: 91.47, height: 47.58, left: 0, top: 104.50, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
    <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 116.39, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
  </div>
</div>

[Multi-query attention](https://huggingface.co/papers/1911.02150) (MQA) is the same as MHA except all Qs share the same K and V.

MQA has the advantage of being more memory efficient and faster at decoding. Each head doesn't need to store a separate K and V. This makes an especially big difference for really long sequences.

[Gemma 2B](https://huggingface.co/google/gemma-2b) uses MQA.

Try calculating the multi-query attention score for the word `Fear` by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table 
  title="Head 1"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "2.0", "1.0", "3.0"],
    ["is", "3.0", "1.5", "4.5"],
  ]}
  className="my-8"
/>

<Table 
  title="Head 2"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "4.0", "1.0", "3.0"],
    ["is", "6.0", "1.5", "4.5"],
  ]}
  className="my-8"
/>

1. For both heads, multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.
  
    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[2.0*1.0, 2.0*1.5]` = `[2.0, 3.0]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0*1.0, 6.0*1.5]` = `[4.0, 9.0]`
      </div>
    </div>

2. Scale the attention scores of each head by dividing by the square root of 2 (the vector dimension).

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[2.0/1.414, 3.0/1.414]` = `[1.414, 2.121]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0/1.414, 9.0/1.414]` = `[2.828, 6.364]`
      </div>
    </div>

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[e^1.414 / (e^1.414 + e^2.121), e^2.121 / (e^1.414 + e^2.121)]` = `[0.33, 0.67]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[e^2.828 / (e^2.828 + e^6.364), e^6.364 / (e^2.828 + e^6.364)]` = `[0.195, 0.971]`
      </div>
    </div>

4. Weight V by the attention scores.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `0.33*3.0`+`0.67*4.5` = `4.01`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `0.195*3.0`+`0.971*4.5` = `4.95`
      </div>
    </div>

5. Concatenate the outputs of each head and multiply by a weight matrix to combine the information.

    `[4.01, 4.95]*[[0.5, 1.0], [1.5, 1.0]]` = `[9.43, 8.96]`

This is the final multi-query attention score for `Fear`.

</Collapsible>

## grouped-query attention [#grouped-query-attention]

<div style={{ display: 'flex', justifyContent: 'center', margin: '2rem 0' }}>
  <div style={{ width: '1000px', height: '350px', position: 'relative', borderRadius: 16, left: '50px' }}>
    <div style={{ width: '100%', height: '100%', position: 'relative', borderRadius: 16 }}>
      {/* Weight labels */}
      <div style={{ width: 11.04, height: 23.50, left: 248.23, top: 45.21, position: 'absolute', color: '#FDA4AF', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>W</div>
      <div style={{ width: 11.04, height: 23.50, left: 248.23, top: 224.21, position: 'absolute', color: '#FDA4AF', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>W</div>
      
      {/* Purple Value boxes */}
      <div style={{ width: 91.47, height: 47.58, left: 195, top: 23.32, position: 'absolute', background: '#EDE9FE', borderRadius: 16, border: '3px #A78BFA solid' }} />
      <div style={{ width: 54.37, height: 23.50, left: 213.41, top: 35.21, position: 'absolute', color: '#A78BFA', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Value</div>
      <div style={{ width: 91.47, height: 47.58, left: 195, top: 218.32, position: 'absolute', background: '#EDE9FE', borderRadius: 16, border: '3px #A78BFA solid' }} />
      <div style={{ width: 54.37, height: 23.50, left: 213.41, top: 230.21, position: 'absolute', color: '#A78BFA', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Value</div>
      
      {/* Blue boxes */}
      <div style={{ width: 91.47, height: 47.58, left: 408, top: 61.32, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
      <div style={{ width: 91.47, height: 47.58, left: 408, top: 115.41, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
      <div style={{ width: 91.47, height: 47.58, left: 408, top: 169.50, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
      <div style={{ width: 91.47, height: 47.58, left: 408.73, top: 223.88, position: 'absolute', background: '#DBEAFE', borderRadius: 16, border: '3px #93C5FD solid' }} />
      
      {/* Animated dashed lines */}
      <AnimatedDashedLine x1={93.03} y1={128.38} x2={169} y2={75.85} />
      <AnimatedDashedLine x1={288} y1={253.32} x2={408} y2={158.32} />
      <AnimatedDashedLine x1={91} y1={23.32} x2={169} y2={75.85} />
      <AnimatedDashedLine x1={288} y1={63.32} x2={408} y2={158.32} />
      <AnimatedDashedLine x1={93.03} y1={318.70} x2={169} y2={266.17} />
      <AnimatedDashedLine x1={91} y1={213.64} x2={169} y2={266.17} />
      
      {/* Orange Key boxes */}
      <div style={{ width: 91.47, height: 47.58, left: 169, top: 58.64, position: 'absolute', background: '#FFEDD5', borderRadius: 16, border: '3px #FB923C solid' }} />
      <div style={{ width: 32.85, height: 23.50, left: 198.17, top: 70.53, position: 'absolute', color: '#FB923C', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Key</div>
      <div style={{ width: 91.47, height: 47.58, left: 169, top: 253.64, position: 'absolute', background: '#FFEDD5', borderRadius: 16, border: '3px #FB923C solid' }} />
      <div style={{ width: 32.85, height: 23.50, left: 198.17, top: 265.53, position: 'absolute', color: '#FB923C', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Key</div>
      
      {/* Green Query boxes */}
      <div style={{ width: 91.47, height: 47.58, left: 0, top: 0, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
      <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 11.89, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
      <div style={{ width: 91.47, height: 47.58, left: 0, top: 104.50, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
      <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 116.39, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
      <div style={{ width: 91.47, height: 47.58, left: 0, top: 190.32, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
      <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 202.21, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
      <div style={{ width: 91.47, height: 47.58, left: 0, top: 294.81, position: 'absolute', background: '#BBF7D0', borderRadius: 16, border: '3px #4ADE80 solid' }} />
      <div style={{ width: 54.37, height: 23.50, left: 18.41, top: 306.71, position: 'absolute', color: '#4ADE80', fontSize: 16, fontFamily: 'Geist Mono', fontWeight: '700', wordWrap: 'break-word' }}>Query</div>
    </div>
  </div>
</div>

[Grouped-query attention](https://huggingface.co/papers/2305.13245) (GQA) is similar to MHA and MQA except each *group* of Qs share the same K and V. The Ks and Vs are different for each group.

GQA combines the best of MHA and MQA. It's faster than MHA because it still has fewer Ks and Vs and it's more expressive than MQA because it has more Qs.

Many modern large language models like [Llama 3](https://huggingface.co/meta-llama/Meta-Llama-3-8B) and [gpt-oss-20b](https://huggingface.co/openai/gpt-oss-20b) use GQA.

Try calculating the grouped-query attention score for the word `Fear` by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table
  title="Group 0, Head 0"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "2.0", "1.0", "2.0"],
    ["is", "3.0", "1.5", "3.0"],
  ]}
  className="my-8"
/>

<Table
  title="Group 0, Head 1"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "4.0", "1.0", "2.0"],
    ["is", "6.0", "1.5", "3.0"],
  ]}
  className="my-8"
/>

<Table 
  title="Group 1, Head 2"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "1.0", "2.0", "4.0"],
    ["is", "1.5", "3.0", "6.0"],
  ]}
  className="my-8"
/>

<Table 
  title="Group 1, Head 3"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "3.0", "2.0", "4.0"],
    ["is", "4.5", "3.0", "6.0"],
  ]}
  className="my-8"
/>

1. For each head in group 0, multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[2.0*1.0, 2.0*1.5]` = `[2.0, 3.0]`

    Head 1 -> `[4.0*1.0, 4.0*1.5]` = `[4.0, 6.0]`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[1.0*2.0, 1.0*3.0]` = `[2.0, 3.0]`

    Head 3 -> `[3.0*2.0, 3.0*3.0]` = `[9.0, 6.0]`

    </div>
    </div>

2. Scale the attention scores of each head by dividing by the square root of 2 (the vector dimension).

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[2.0/1.414, 3.0/1.414]` = `[1.414, 2.121]`

    Head 1 -> `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[2.0/1.414, 3.0/1.414]` = `[1.414, 2.121]`

    Head 3 -> `[9.0/1.414, 6.0/1.414]` = `[6.364, 4.243]`

    </div>
    </div>

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[e^1.414 / (e^1.414 + e^2.121), e^2.121 / (e^1.414 + e^2.121)]` = `[0.33, 0.67]`

    Head 1 -> `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.805]`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[e^1.414 / (e^1.414 + e^2.121), e^2.121 / (e^1.414 + e^2.121)]` = `[0.33, 0.67]`

    Head 3 -> `[e^6.364 / (e^6.364 + e^4.243), e^4.243 / (e^6.364 + e^4.243)]` = `[0.892, 0.107]`

    </div>
    </div>

4. Weight V by the attention scores.

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[0.33*2.0 + 0.67*3.0]` = `2.67`

    Head 1 -> `[0.195*2.0 + 0.805*3.0]` = `2.81`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[0.33*4.0 + 0.67*6.0]` = `5.34`

    Head 3 -> `[0.892*4.0 + 0.107*6.0]` = `4.21`

    </div>
    </div>

5. Concatenate the heads of each group and multiply by a weight matrix to combine the information.

    `[2.67, 2.81. 5.34, 4.21] * [[1.0, 0.0], [0.5, 0.5], [1.0, 2.0], [0.1, 1.0]]` = `[9.836, 16.295]`

This is the final grouped-query attention score for `Fear`.

</Collapsible>

## summary [#summary]

Self-attention is powerful, but it's also computationally expensive when sequences start getting longer. Newer attention algorithms, like [FlashAttention](https://github.com/Dao-AILab/flash-attention) and [PagedAttention](https://blog.vllm.ai/2023/06/20/vllm.html), handle longer sequences more memory efficiently.

**The key takeaway is that self-attention is a weighted sum of contextual information of all words. The weights reflect each surrounding word's relevance to the current word.**

## resources [#resources]

- [Attention Is All You Need](https://huggingface.co/papers/1706.03762)
- [Fast Transformer Decoding: One Write-Head is All You Need](https://huggingface.co/papers/1911.02150)
- [GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints](https://huggingface.co/papers/2305.13245)
- Youtube videos by [3Blue1Brown](https://www.youtube.com/watch?v=eMlx5fFNoYc) and [Andrej Karpathy](https://www.youtube.com/watch?v=kCc8FmEb1nY&t=2533s)