export const metadata = {
  title: 'Attention please',
  description: 'An overview of different attention variants',
  openGraph: {
    title: 'Attention please',
    description: 'An overview of different attention variants',
    images: [{ url: '/og/attention-please' }]
  }
};

<FloatingTOC
  items={[
    { text: "self-attention", href: "#self-attention" },
    { text: "causal self-attention", href: "#causal-self-attention" },
    { text: "multi-head attention", href: "#multi-head-attention" },
    { text: "multi-query attention", href: "#multi-query-attention" },
    { text: "grouped-query attention", href: "#grouped-query-attention" },
    { text: "multi-head latent attention", href: "#multi-head-latent-attention" },
    { text: "flashattention", href: "#flashattention" },
    { text: "flashattention-2", href: "#flashattention-2" },
    { text: "flashattention-3", href: "#flashattention-3" },
    { text: "summary", href: "#summary" },
    { text: "resources", href: "#resources" }
  ]}
/>

> An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.
> - [Attention Is All You Need](https://huggingface.co/papers/1706.03762)

It's amazing that an idea so simple has such a tremendous and lasting impact. This idea is described in only two sentences, but it is consumed by millions of people using large language models daily.

This post tries to very simply and very plainly explain how attention, and variants of it, work.

## self-attention [#self-attention]

Self-attention (scaled dot-product attention) computes how much attention each word in a sequence assigns to every other word in that same sequence. It's what makes transformers contextually aware.

<SelfAttentionDiagram />

You need 3 matrices to compute self-attention. These matrices are created by multiplying <HoverWord 
  word="word embeddings"
  description="Vectors of numbers that represent words in a way that captures meaning and relationships."
/> by 3 <HoverWord
  word="weight matrices"
  description="Learnable parameters optimized during training."
/>
(W<sub>k</sub>, W<sub>q</sub>, W<sub>v</sub>).

- Query (Q) is the information you're looking for. It is compared to every K (including itself) to calculate how much attention to pay to each word.
- Key (K) is the information a word contains. It is multiplied (<HoverWord
  word="dot product"
  description="A mathematical operation that compares how similar two vectors are. In the context of transformers, it compares how similar two tokens are."
/>) by Q to get the attention scores for each word.

  The scores are *scaled* by dividing by the square root of the vector dimension. For example, if the dimension is 64, divide the attention scores by 8. Scaling prevents the attention scores from becoming too large or too small.

  Scores are converted into probabilities that add up to 1 with the <HoverWord
    word="softmax"
    description="A function that exponentiates a value and divides by the sum of all the exponentiated values."
  /> function. Scaling also smooths out the softmax function by preventing any one value from getting too large and overwhelming the rest.

- Value (V) is the information each word contributes. It weights each word with the attention score to determine what information every other word offers.

Try calculating the self-attention score by hand in the following sequence to really get a feel for how it works.

<Collapsible trigger="Show calculations">

<Table 
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "[0.2, 0.1, 0.8]", "[0.3, 0.5, 0.2]", "[0.1, 0.7, 0.4]"],
    ["is", "[0.5, 0.2, 0.3]", "[0.1, 0.4, 0.6]", "[0.8, 0.1, 0.2]"],
  ]}
  className="my-8"
/>

1. Multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.

    `[0.2, 0.1, 0.8]*[0.3, 0.5, 0.2]` = `0.2*0.3 + 0.1*0.5 + 0.8*0.2` = `0.27`

    `[0.2, 0.1, 0.8]*[0.1, 0.4, 0.6]` = `0.2*0.1 + 0.1*0.4 + 0.8*0.6` = `0.54`

2. Scale the attention scores by dividing by the square root of 3 (the vector dimension).

    `[0.27/1.732, 0.54/1.732]` = `[0.156, 0.312]`

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    `[e^0.156 / (e^0.156 + e^0.312), e^0.312 / (e^0.156 + e^0.312)]` = `[0.46, 0.54]`

4. Weight V by the attention scores.

    `0.46*[0.1, 0.7, 0.4]` = `[0.046, 0.322, 0.184]`

    `0.54*[0.8, 0.1, 0.2]` = `[0.432, 0.054, 0.108]`

5. Add the weighted values together.

    `[0.046+0.432, 0.322+0.054, 0.184+0.108]` = `[0.478, 0.376, 0.292]`

This is the final self-attention score for `Fear`.
</Collapsible>

## causal self-attention [#causal-self-attention]

Causal self-attention is used in decoder models like [GPT](https://huggingface.co/openai-community/gpt2). Decoder models predict the next word in a sequence, so it is important to mask the next words to prevent the model from seeing them.

<CausalDiagram />

The mask sets words that should be blocked to -∞, which is converted to ~0 by the softmax.

Try calculating the causal self-attention score by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table 
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "[0.2, 0.1, 0.8]", "[0.3, 0.5, 0.2]", "[0.1, 0.7, 0.4]"],
    ["is", "[0.5, 0.2, 0.3]", "[0.1, 0.4, 0.6]", "[0.8, 0.1, 0.2]"],
    ["the", "[0.1, 0.6, 0.3]", "[0.4, 0.2, 0.5]", "[0.2, 0.9, 0.1]"],
  ]}
  className="my-8"
/>

1. Multiply Q<sub>is</sub> by K for every word in the sequence to get the attention score.

    `[0.5, 0.2, 0.3]*[0.3, 0.5, 0.2]` = `0.5*0.3+0.2*0.5+0.3*0.2` = `0.31`

    `[0.5, 0.2, 0.3]*[0.1, 0.4, 0.6]` = `0.5*0.1+0.2*0.4+0.3*0.6` = `0.31`

    `[0.5, 0.2, 0.3]*[0.4, 0.2, 0.5]` = `0.5*0.4+0.2*0.2+0.3*0.5` = `0.39`

    The attention score is `[0.31, 0.31, 0.39]`.

2. Scale the attention scores by dividing by the square root of 3 (the vector dimension).

    `[0.31/1.732, 0.31/1.732, 0.39/1.732]` = `[0.179, 0.179, 0.225]`

3. Set `0.225` to `-inf` to block attention to the future word (`the`).

    `[0.179, 0.179, -inf]`
    
    The rest of the calculation is the same as self-attention.
</Collapsible>

## multi-head attention [#multi-head-attention]

Multi-head attention (MHA) adds more heads to learn from different perspectives.

<MHADiagram />

The calculations are the same as self-attention, but the <HoverWord
  word="embedding size"
  description="The size of the vector used to represent a word. A larger size includes more information, but it also increases the computational cost."
/> is split by the number of heads. Each head independently computes the scaled dot-product attention on their slice of data. At the end, the outputs are combined and multiplied by a weight matrix to blend all the information together.

Try calculating the multi-head attention score by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table 
  title="Head 1"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "2.0", "2.0", "2.0"],
    ["is", "3.0", "3.0", "3.0"],
  ]}
  className="my-8"
/>

<Table 
  title="Head 2"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "4.0", "1.0", "3.0"],
    ["is", "6.0", "1.5", "4.5"],
  ]}
  className="my-8"
/>

1. For both heads, multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[2.0*2.0, 2.0*3.0]` = `[4.0, 6.0]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0*1.0, 4.0*1.5]` = `[4.0, 6.0]`
      </div>
    </div>

2. Scale the attention scores of each head by dividing by the square root of 2 (the vector dimension).

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`
      </div>
    </div>

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.804]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.804]`
      </div>
    </div>

3. Weight V by the attention scores.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `0.195*2.0`+`0.804*3.0` = `2.802`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `0.195*3.0`+`0.804*4.5` = `4.203`
      </div>
    </div>

4. Concatenate the outputs of each head and multiply by a <HoverWord
  word="transposed"
  description="The transpose of a matrix switches the rows and columns. A m x n matrix becomes a n x m matrix."
/> weight matrix (Wᵀ) to combine the information.

    `[2.802, 4.203]*[1.0, 1.0]ᵀ` = `7.005`

This is the final multi-head attention score for `Fear`.

</Collapsible>

## multi-query attention [#multi-query-attention]

[Multi-query attention](https://huggingface.co/papers/1911.02150) (MQA) is the same as MHA except every Q shares the same K, V.

<MQADiagram />

MQA is more memory-efficient and faster at decoding because each head doesn't need to store a separate K, V. This makes an especially big difference for really long sequences.

Try calculating the multi-query attention score by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table 
  title="Head 1"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "2.0", "1.0", "3.0"],
    ["is", "3.0", "1.5", "4.5"],
  ]}
  className="my-8"
/>

<Table 
  title="Head 2"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "4.0", "1.0", "3.0"],
    ["is", "6.0", "1.5", "4.5"],
  ]}
  className="my-8"
/>

1. For both heads, multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.
  
    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[2.0*1.0, 2.0*1.5]` = `[2.0, 3.0]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0*1.0, 4.0*1.5]` = `[4.0, 6.0]`
      </div>
    </div>

2. Scale the attention scores of each head by dividing by the square root of 2 (the vector dimension).

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[2.0/1.414, 3.0/1.414]` = `[1.414, 2.121]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`
      </div>
    </div>

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `[e^1.414 / (e^1.414 + e^2.121), e^2.121 / (e^1.414 + e^2.121)]` = `[0.33, 0.67]`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.805]`
      </div>
    </div>

4. Weight V by the attention scores.

    <div className="flex gap-8 items-start">
      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-green-500">Head 1</span>
        </div>
        `0.33*3.0`+`0.67*4.5` = `4.01`
      </div>

      <div className="flex-1">
        <div className="pb-1 mb-2">
          <span className="border-b-2 border-dotted border-orange-500">Head 2</span>
        </div>
        `0.195*3.0`+`0.805*4.5` = `4.21`
      </div>
    </div>

5. Concatenate the outputs of each head and multiply by a weight matrix to combine the information.

    `[4.01, 4.21]*[[0.5, 1.0], [1.5, 1.0]]` = `[8.32, 8.22]`

This is the final multi-query attention score for `Fear`.

</Collapsible>

## grouped-query attention [#grouped-query-attention]

[Grouped-query attention](https://huggingface.co/papers/2305.13245) (GQA) is similar to MHA and MQA except *groups* of Q share the same K, V. K, V is different for each group.

<GQADiagram />

GQA is the middle ground between MHA and MQA. It's faster than MHA and more expressive than MQA.

Try calculating the grouped-query attention score by hand in the following sequence.

<Collapsible trigger="Show calculations">

<Table
  title="Group 0, Head 0"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "2.0", "1.0", "2.0"],
    ["is", "3.0", "1.5", "3.0"],
  ]}
  className="my-8"
/>

<Table
  title="Group 0, Head 1"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "4.0", "1.0", "2.0"],
    ["is", "6.0", "1.5", "3.0"],
  ]}
  className="my-8"
/>

<Table 
  title="Group 1, Head 2"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "1.0", "2.0", "4.0"],
    ["is", "1.5", "3.0", "6.0"],
  ]}
  className="my-8"
/>

<Table 
  title="Group 1, Head 3"
  headers={["Word", "Q", "K", "V"]}
  data={[
    ["Fear", "3.0", "2.0", "4.0"],
    ["is", "4.5", "3.0", "6.0"],
  ]}
  className="my-8"
/>

1. For each head in group 0, multiply Q<sub>Fear</sub> by K for every word in the sequence to get the attention score.

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[2.0*1.0, 2.0*1.5]` = `[2.0, 3.0]`

    Head 1 -> `[4.0*1.0, 4.0*1.5]` = `[4.0, 6.0]`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[1.0*2.0, 1.0*3.0]` = `[2.0, 3.0]`

    Head 3 -> `[3.0*2.0, 3.0*3.0]` = `[6.0, 9.0]`

    </div>
    </div>

2. Scale the attention scores of each head by dividing by the square root of 2 (the vector dimension).

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[2.0/1.414, 3.0/1.414]` = `[1.414, 2.121]`

    Head 1 -> `[4.0/1.414, 6.0/1.414]` = `[2.828, 4.243]`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[2.0/1.414, 3.0/1.414]` = `[1.414, 2.121]`

    Head 3 -> `[6.0/1.414, 9.0/1.414]` = `[4.243, 6.364]`

    </div>
    </div>

3. Apply the softmax function to convert the attention scores into probabilities that add up to 1.

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[e^1.414 / (e^1.414 + e^2.121), e^2.121 / (e^1.414 + e^2.121)]` = `[0.33, 0.67]`

    Head 1 -> `[e^2.828 / (e^2.828 + e^4.243), e^4.243 / (e^2.828 + e^4.243)]` = `[0.195, 0.805]`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[e^1.414 / (e^1.414 + e^2.121), e^2.121 / (e^1.414 + e^2.121)]` = `[0.33, 0.67]`

    Head 3 -> `[e^4.243 / (e^4.243 + e^6.364), e^6.364 / (e^4.243 + e^6.364)]` = `[0.107, 0.893]`

    </div>
    </div>

4. Weight V by the attention scores.

    <div className="flex gap-8 items-start">
    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-green-500">Group 0</span></div>

    Head 0 -> `[0.33*2.0 + 0.67*3.0]` = `2.67`

    Head 1 -> `[0.195*2.0 + 0.805*3.0]` = `2.81`

    </div>

    <div className="flex-1">
    <div className="pb-1 mb-2"><span className="border-b-2 border-dotted border-orange-500">Group 1</span></div>

    Head 2 -> `[0.33*4.0 + 0.67*6.0]` = `5.34`

    Head 3 -> `[0.107*4.0 + 0.893*6.0]` = `5.79`

    </div>
    </div>

5. Concatenate the heads of each group and multiply by a weight matrix to combine the information.

    `[2.67, 2.81, 5.34, 5.79] * [[1.0, 0.0], [0.5, 0.5], [1.0, 2.0], [0.1, 1.0]]` = `[9.994, 17.875]`

This is the final grouped-query attention score for `Fear`.

</Collapsible>

## multi-head latent attention [#multi-head-latent-attention]

[Multi-head latent attention](https://huggingface.co/papers/2405.04434) (MLA) stores a <HoverWord 
  word="compressed"
  description="Low-rank compression is an operation that factors a large matrix into two smaller matrices. For example, a 1000x1000 matrix M has 1 million values. If it has rank 64, then the matrix can be represented by two 1000x64 matrices. This only has 128,000 values instead of a million."
/> version of KV (*latent*) to save more space in the <HoverWord
  word="cache"
  description="The KV cache stores past attention context during generation. It is more efficient than recomputing KV every time. When context length grows, it requires more memory in the cache."
/>. At inference, the latents Q and KV are multiplied by **W<sup>combined</sup>** to compute attention.

<MLADiagram />

The usual approach expands the latent KV back to its full size by multiplying by an up-projection matrix W<sup>UK</sup>, before computing attention. This takes up more memory and defeats the purpose of compression.

<div className="text-center text-emerald-400 font-bold">(W<sup>UQ</sup> * c<sup>Q</sup>) * (W<sup>UK</sup> * c<sup>KV</sup>)</div>

MLA skips this step by "absorbing" or pre-multiplying W<sup>UQ</sup> and W<sup>UK</sup> into a single matrix, W<sup>combined</sup>, ahead of time. This means the latents never need to be expanded during inference.

<div className="text-center text-emerald-400 font-bold">c<sup>Q</sup> * (W<sup>UK</sup> * W<sup>UQ</sup>) * c<sup>KV</sup></div>
<div className="text-center text-emerald-400 font-bold">W<sup>combined</sup> = (W<sup>UQ</sup>)<sup>T</sup> * W<sup>UK</sup></div>
<div className="text-center text-emerald-400 font-bold">score = (c<sup>Q</sup>)<sup>T</sup> * W<sup>combined</sup> * c<sup>KV</sup></div>

Rearranging the maths like this makes it incompatible with [rotary position embeddings](https://huggingface.co/papers/2104.09864) (RoPE) though. RoPE adds a <HoverWord
  word="position-dependent rotation"
  description="R<sub>t</sub> and R<sub>j</sub> are the token positions (R for short here). When multiplying Q and K, R encodes the *relative* position between them."
/> (R) to K and Q.

<div className="text-center text-emerald-400 font-bold">score = (c<sup>Q</sup>)<sup>T</sup> * (W<sup>UQ</sup>)<sup>T</sup> * R<sub>t</sub><sup>T</sup> * R<sub>j</sub> * W<sup>UK</sup> * c<sup>KV</sup></div>

RoPE rotates Q and K by their token positions (*t,j*).

<div className="text-center text-emerald-400 font-bold">q<sub>t</sub> = R<sub>t</sub>q<sub>t</sub></div>
<div className="text-center text-emerald-400 font-bold">k<sub>j</sub> = R<sub>j</sub>k<sub>j</sub></div>
<div className="text-center text-emerald-400 font-bold">score = q<sub>t</sub>(R<sub>t</sub>R<sub>j</sub>)k<sub>j</sub></div>

The term, R<sub>t</sub>R<sub>j</sub>, depend on the (*t,j*) pair. There is no single fixed matrix you can precompute that works for all (*t,j*) pairs, so it can't be folded into W<sup>combined</sup>. Using RoPE this way would require recomputing the full K from the latent during generation (increases latency) or caching the full RoPE-applied keys (increases memory).

Decoupling the *positional information* from the *content* solves this. The *content* calculation is the same, but the positional information is applied in a separate stream.

<div className="text-center text-emerald-400 font-bold">q<sup>R</sup> = RoPE(W<sup>QR</sup> * h<sub>t</sub>)</div>
<div className="text-center text-emerald-400 font-bold">k<sup>R</sup> = RoPE(W<sup>KR</sup> * h<sub>j</sub>)</div>
<div className="text-center text-emerald-400 font-bold">score = q<sup>C</sup> * k<sup>C</sup> + q<sup>R</sup> * k<sup>R</sup></div>

k<sup>R</sup> is cached, and the content and positional scores are summed when computing attention. This way, positional information flows through small decoupled vectors and content information can still flow through the latents.

## flashattention [#flashattention]

[FlashAttention](https://huggingface.co/papers/2205.14135) changes how the attention calculation is executed to minimize memory traffic to and from the GPU's slower high-bandwidth global memory (HBM). The calculation is done on the faster on-chip shared memory (SRAM) and registers, without fully materializing the entire attention score matrix in HBM.

<FlashAttentionDiagram />

- Q, K, and V are tiled into blocks that fit in SRAM. Tiling lets the calculation be performed in a CUDA kernel.
- In the first block, calculate a row-wise max *m<sub>1</sub>* and a sum *l<sub>1</sub>* for the attention scores.
- After processing the second block, update the row-wise max to *m<sub>2</sub>*. Rescale *l<sub>1</sub>* and the partial output before adding the new updates.
- Repeat for each calculation.

Attention scores are streamed over blocks to avoid storing the entire attention score matrix in memory. The softmax calculation is exactly the same. Only Q, K, V, the final output, and the softmax normalization factor from the forward pass are stored in HBM.

The backward pass uses the same idea to avoid storing the attention probabilities P in memory. P is required for computing gradients with respect to Q, K, and V. FlashAttention recomputes P block-by-block, uses the same softmax statistics from the forward pass (*m*, *l*), and accumulates the gradients.

Speed ups increase with sequence length. But for short sequences, attention is less memory-bound and there's less benefit.

## flashattention-2 [#flashattention-2]

[FlashAttention-2](https://huggingface.co/papers/2307.08691) improves FlashAttention by reducing non-matmul FLOPs and scheduling more work on the GPU.

- GPUs use specialized compute units, Tensor Cores on Nvidia GPUs, for fast matmuls. In FlashAttention, every block rescales the output with the sum *l*. 
  
  FlashAttention-2 delays rescaling to the end to avoid many scalar divisions. This reduces the number of non-matmul operations.

<FAParallelismDiagram />

- FlashAttention parallelizes over *batch size x num heads x query blocks*. For long sequences with small batches, there are fewer head blocks and streaming multiprocessors (SM) occupancy drops.

  FlashAttention-2 increases tiling and scheduling so more query blocks run in parallel. This boosts SM usage for long sequences.

<FAWarpDiagram />

- Warps are groups of threads in a thread block. FlashAttention split the work on K, V and Q is accessible by all warps. After computing attention, warps write the partial results to shared memory, synchronize, and reduce.

   FlashAttention-2 splits the work on Q and K, V is accessible by all warps. Each warp computes a partial result that doesn't require synchronization until the end. Assigning different Q blocks to different warps minimizes shared memory traffic.

## flashattention-3 [#flashattention-3]

[FlashAttention-3](https://huggingface.co/papers/2407.08608) optimizes for newer hardware, like H100 GPUs, that support asynchrony. Specialized compute units run in parallel. Tensor cores can do fast matmuls, Tensor Memory Accelerator (TMA) loads data from HBM, and CUDA cores can perform slower computations like softmax.

<FA3PipelineDiagram />

- Warps performed the same work in FlashAttention-2, loading and computing.

  FlashAttention-3 specializes warps to different tasks. Producer warps load K, V blocks from HBM to SRAM with TMA. Consumer warps compute attention using data in SRAM with tensor cores. The producer can prefetch the next block while the consumer is working on the current block. It overlaps loading and computation.

<FA3WGMMADiagram />

- The output O depends on P. P is calculated from the softmax(S), and S depends on the attention score calculation.

  FlashAttention-3 uses Warp Group Matrix Multiply-Accumulate (WGMMA) to asynchronously perform the computation. It pipelines blocks so while softmax executes on one block of the scores matrix, WGMMA executes to compute the next block. There are two pipelines running in parallel, WGMMA executions and non-WGMMA executions.

- FP8 quantization is sensitive to outlier features in large language models (LLMs). A few dimensions in hidden states can have very large values. When quantized to FP8, the issue manifests as precision loss.

<FP8OutlierDiagram />

   FlashAttention-3 uses a different scale per block. Each block can use the full FP8 range for *its* values. The outlier block gets a big scale and the normal blocks get a tiny scale. This way, precision is preserved locally.

<IncoherentDiagram />

   If an outlier is in a normal block, FlashAttention-3 fixes this by spreading the outlier across all dimensions before quantization. It multiplies Q, K by a random orthogonal matrix to redistribute the outlier. This way, no single dimension dominates a block.

## summary [#summary]

Self-attention is a weighted sum of contextual information of all words. The weights reflect each surrounding word's relevance to the current word.

But attention is memory-bound. New attention algorithms optimize *how* the attention calculation is executed, whether it's sharing the same K, V or streaming the attention function.

## resources [#resources]

- [Attention Is All You Need](https://huggingface.co/papers/1706.03762)
- [Fast Transformer Decoding: One Write-Head is All You Need](https://huggingface.co/papers/1911.02150)
- [GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints](https://huggingface.co/papers/2305.13245)
- [FlashAttention](https://huggingface.co/papers/2205.14135), [FlashAttention-2](https://huggingface.co/papers/2307.08691), [FlashAttention-3](https://huggingface.co/papers/2407.08608)
- Youtube videos by [3Blue1Brown](https://www.youtube.com/watch?v=eMlx5fFNoYc) and [Andrej Karpathy](https://www.youtube.com/watch?v=kCc8FmEb1nY&t=2533s)